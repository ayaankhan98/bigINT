/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 * Permission is hereby granted, free of charge, to any person
 * or organization obtaining a copy of the software and
 * accompanying documentation covered by this license
 * (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole or
 * in part, and all derivative works of the Software, unless such copies
 * or derivative works are solely in the form of machine-executable
 * object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
 * WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include <istream>
#include <ostream>
#include <bigint.hpp>
#include <algorithm>
#include <complex>

namespace libbig
{
    largeInt largeInt::operator*(const largeInt &next_number) {

        auto remove_zeroes = [] (const largeInt &x) {
            for(int j=0; j < x.number.length(); ++j) {
                if((x.number[j]) != '0') {
                    return largeInt(x.number.substr(j, x.number.length()));
                }
            }
            return largeInt("0");
        };

        auto append_zeroes = [] (const largeInt &x, const int factor) {
            largeInt Answer = x;
            for(int k = 0; k < factor; k++) {
                Answer.number.push_back('0');
            }

            return Answer;
        };

        auto simple_multiplication = [] (const largeInt &x, const largeInt &y) {

            largeInt x1 = x;
            largeInt x2 = y;
            largeInt adder;
            largeInt Answer(0);

            if(x1.number.length() == 0 || x2.number.length() == 0) {
                return largeInt();
            }

            int carry { 0 }, temp, f=0;
            for(auto i=x1.number.rbegin(); i!=x1.number.rend(); ++i) {
                for(auto j=x2.number.rbegin(); j!=x2.number.rend(); ++j) {
                    temp = char_int_converter(*i) * char_int_converter(*j) + carry;
                    carry = temp/10;
                    adder.number.push_back(char_int_converter(temp%10));
                }
                if(carry) {
                    adder.number.push_back(char_int_converter(carry));
                    carry = 0;
                }
                std::reverse(adder.number.begin(), adder.number.end());
                for(int k=1; k <= f; ++k) {
                    adder.number.push_back('0');
                }
                Answer = Answer + adder;
                adder = largeInt();
                f += 1;
            }

            if(x1.sign != x2.sign)
                Answer.sign = NEGATIVE;

            return Answer;
        };

        auto get_polynomial = [] (const largeInt &num) {
            const int len = num.number.length();
            int factor = 1;
            complexCoeffs Answer;
            int i = 1;
            while (i != len+1) {
                std::complex<float> single(static_cast<float> (factor*char_int_converter(num.number[len - i])), 0.0);
                Answer.push_back(single);
                factor *= 10;
                ++i;
            }
            std::cout<<std::endl;
            return Answer;
        };

        largeInt x = *this;
        largeInt y = next_number;
        
        if(x.number == "0" || y.number == "0" || x.number.length() == 0 || y.number.length() == 0) {
            return largeInt("0");
        }
        else if(x.number.length() == 1 || y.number.length() == 1) {
            return simple_multiplication(x, y);
        }

        const complexCoeffs polynomial_x = get_polynomial(x);
        const complexCoeffs polynomial_y = get_polynomial(y);
        
        const complexCoeffs DFT_x = fast_fourier_transform(false, polynomial_x);
        const complexCoeffs DFT_y = fast_fourier_transform(false, polynomial_y);

        const int min = std::min(DFT_x.size(), DFT_y.size());

        complexCoeffs DFT_xy;

        for(int i = 0; i<min; ++i) {
            DFT_xy.push_back(DFT_x[i]*DFT_y[i]);
        }

        largeInt Answer;
        complexCoeffs IDFT_xy = fast_fourier_transform(true, DFT_xy);
        for(int i = 0; i<IDFT_xy.size(); ++i) {
            largeInt single(std::to_string(static_cast<int>(std::abs(IDFT_xy[i]))));
            Answer = Answer + single;
        }
        return Answer;
    }

    largeInt largeInt::operator*(int next_number) {
        return *this * largeInt(next_number);
    }

    largeInt largeInt::operator*(int64_t next_number) {
        return *this * largeInt(std::to_string(next_number));
    }
} // namespace libbig
